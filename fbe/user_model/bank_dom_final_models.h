// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: user_model.fbe
// Version: 1.7.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_final_models.h"

#include "bank_dom.h"

namespace FBE {

// Fast Binary Encoding ::bank_dom::Transaction final model
template <>
class FinalModel<::bank_dom::Transaction>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::bank_dom::Transaction& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::bank_dom::Transaction& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::bank_dom::Transaction& fbe_value) const noexcept;

    // Set the struct value
    size_t set(const ::bank_dom::Transaction& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::bank_dom::Transaction& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<std::string> from;
    FinalModel<std::string> to;
    FinalModel<uint32_t> amount;
    FinalModel<uint64_t> time;
};

namespace bank_dom {

// Fast Binary Encoding Transaction final model
class TransactionFinalModel : public FBE::Model
{
public:
    TransactionFinalModel() : _model(this->buffer(), 8) {}
    TransactionFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::bank_dom::Transaction>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::bank_dom::Transaction& value);
    // Deserialize the struct value
    size_t deserialize(::bank_dom::Transaction& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::bank_dom::Transaction> _model;
};

} // namespace bank_dom

// Fast Binary Encoding ::bank_dom::Logs final model
template <>
class FinalModel<::bank_dom::Logs>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::bank_dom::Logs& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::bank_dom::Logs& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::bank_dom::Logs& fbe_value) const noexcept;

    // Set the struct value
    size_t set(const ::bank_dom::Logs& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::bank_dom::Logs& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<::bank_dom::Transaction> data;
};

namespace bank_dom {

// Fast Binary Encoding Logs final model
class LogsFinalModel : public FBE::Model
{
public:
    LogsFinalModel() : _model(this->buffer(), 8) {}
    LogsFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::bank_dom::Logs>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::bank_dom::Logs& value);
    // Deserialize the struct value
    size_t deserialize(::bank_dom::Logs& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::bank_dom::Logs> _model;
};

} // namespace bank_dom

// Fast Binary Encoding ::bank_dom::User final model
template <>
class FinalModel<::bank_dom::User>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::bank_dom::User& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::bank_dom::User& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::bank_dom::User& fbe_value) const noexcept;

    // Set the struct value
    size_t set(const ::bank_dom::User& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::bank_dom::User& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<uint32_t> balance;
    FinalModel<uint64_t> password;
    FinalModel<std::optional<::bank_dom::Logs>> logs;
};

namespace bank_dom {

// Fast Binary Encoding User final model
class UserFinalModel : public FBE::Model
{
public:
    UserFinalModel() : _model(this->buffer(), 8) {}
    UserFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::bank_dom::User>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::bank_dom::User& value);
    // Deserialize the struct value
    size_t deserialize(::bank_dom::User& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::bank_dom::User> _model;
};

} // namespace bank_dom

// Fast Binary Encoding ::bank_dom::Global final model
template <>
class FinalModel<::bank_dom::Global>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::bank_dom::Global& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 4; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::bank_dom::Global& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::bank_dom::Global& fbe_value) const noexcept;

    // Set the struct value
    size_t set(const ::bank_dom::Global& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::bank_dom::Global& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<std::string> keys;
    FinalModelVector<::bank_dom::User> users;
};

namespace bank_dom {

// Fast Binary Encoding Global final model
class GlobalFinalModel : public FBE::Model
{
public:
    GlobalFinalModel() : _model(this->buffer(), 8) {}
    GlobalFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::bank_dom::Global>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::bank_dom::Global& value);
    // Deserialize the struct value
    size_t deserialize(::bank_dom::Global& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::bank_dom::Global> _model;
};

} // namespace bank_dom

} // namespace FBE
